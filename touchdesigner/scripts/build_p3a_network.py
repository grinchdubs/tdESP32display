"""
TouchDesigner Network Builder for P3A Integration
Programmatically creates Timer CHOP, Execute DAT, and wires them together

Usage: exec(open(r'touchdesigner/scripts/build_p3a_network.py').read())

This script will create:
- Timer CHOP for periodic uploads
- Execute DAT with callbacks to trigger uploads
- Properly wired and configured network

Author: Generated for P3A Display Integration
License: Apache-2.0
"""

def build_p3a_integration_network(parent_comp=None, render_top_name='render_out',
                                    upload_rate=2, ip_address='p3a.local',
                                    format='JPEG', quality=75):
    """
    Build P3A integration network in TouchDesigner

    Args:
        parent_comp: Parent component to create operators in (default: /project1)
        render_top_name: Name of your render TOP
        upload_rate: Upload rate in Hz (default: 2 fps)
        ip_address: P3A device IP or hostname
        format: Image format (PNG, JPEG, WEBP)
        quality: JPEG/WebP quality 0-100

    Returns:
        dict: Created operators {'timer': timer_chop, 'execute': execute_dat}
    """

    # Default to /project1 if no parent specified
    if parent_comp is None:
        parent_comp = op('/project1')

    print(f"Building P3A integration network in {parent_comp.path}...")

    # Check if render TOP exists
    render_top = op(render_top_name)
    if render_top is None:
        print(f"WARNING: Render TOP '{render_top_name}' not found.")
        print(f"Make sure to create it before uploading.")

    # Create Timer CHOP
    timer_name = 'p3a_upload_timer'
    if op(f'{parent_comp.path}/{timer_name}') is not None:
        print(f"Timer '{timer_name}' already exists, removing...")
        op(f'{parent_comp.path}/{timer_name}').destroy()

    timer_chop = parent_comp.create(timerCHOP, timer_name)
    timer_chop.par.initialize.pulse()
    timer_chop.par.start.expr = 'me.time.frame == 1'
    timer_chop.par.length = 1000000  # Very long duration
    timer_chop.par.timeout = upload_rate  # Upload rate in Hz
    timer_chop.par.done = 'repeat'
    timer_chop.par.showcook = True
    timer_chop.nodeX = 0
    timer_chop.nodeY = 0

    print(f"✓ Created Timer CHOP '{timer_name}' (rate: {upload_rate} Hz)")

    # Create Execute DAT
    execute_name = 'p3a_upload_execute'
    if op(f'{parent_comp.path}/{execute_name}') is not None:
        print(f"Execute DAT '{execute_name}' already exists, removing...")
        op(f'{parent_comp.path}/{execute_name}').destroy()

    execute_dat = parent_comp.create(executeDAT, execute_name)
    execute_dat.nodeX = 200
    execute_dat.nodeY = 0

    # Set CHOP reference
    execute_dat.par.chopexec0 = timer_chop
    execute_dat.par.chopexec1 = ''
    execute_dat.par.chopexec2 = ''
    execute_dat.par.chopexec3 = ''
    execute_dat.par.chopexec4 = ''
    execute_dat.par.chopexec5 = ''
    execute_dat.par.chopexec6 = ''
    execute_dat.par.chopexec7 = ''
    execute_dat.par.chopexec8 = ''
    execute_dat.par.chopexec9 = ''

    # Enable appropriate callbacks
    execute_dat.par.valuechange = True
    execute_dat.par.offtoOn = True
    execute_dat.par.whileon = False
    execute_dat.par.ontOff = False

    # Build Execute DAT code with upload configuration
    execute_code = f'''# P3A Upload Execute DAT
# Automatically generated by build_p3a_network.py
# Triggers upload to P3A display on timer pulse

# Configuration
RENDER_TOP = '{render_top_name}'
IP_ADDRESS = '{ip_address}'
FORMAT = '{format}'
QUALITY = {quality}

def onValueChange(channel, sampleIndex, val, prev):
	"""Triggered when timer CHOP value changes"""
	# Only trigger on rising edge (0 to 1 transition)
	if val > 0 and prev <= 0:
		try:
			# Import required modules
			import requests
			import numpy as np
			from PIL import Image
			import io

			# Get render TOP
			top_op = op(RENDER_TOP)
			if top_op is None:
				print(f"ERROR: TOP '{{RENDER_TOP}}' not found")
				return

			# Get image data
			img_array = top_op.numpyArray(delayed=False)
			if img_array is None or img_array.size == 0:
				print(f"ERROR: TOP '{{RENDER_TOP}}' has no image data")
				return

			# Convert to PIL Image
			img_array = np.flipud(img_array)
			img_uint8 = (img_array * 255).astype(np.uint8)

			if img_uint8.shape[2] == 4:
				img = Image.fromarray(img_uint8[:, :, :3], mode='RGB')
			else:
				img = Image.fromarray(img_uint8, mode='RGB')

			# Resize to 720x720
			if img.size != (720, 720):
				img = img.resize((720, 720), Image.LANCZOS)

			# Encode
			buffer = io.BytesIO()
			if FORMAT == 'PNG':
				img.save(buffer, format='PNG', compress_level=6)
				content_type = 'image/png'
				filename = 'td_frame.png'
			elif FORMAT == 'JPEG':
				img.save(buffer, format='JPEG', quality=QUALITY, optimize=True)
				content_type = 'image/jpeg'
				filename = 'td_frame.jpg'
			elif FORMAT == 'WEBP':
				img.save(buffer, format='WEBP', quality=QUALITY)
				content_type = 'image/webp'
				filename = 'td_frame.webp'

			file_size = buffer.tell()
			buffer.seek(0)

			# Upload
			url = f'http://{{IP_ADDRESS}}/upload/image'
			files = {{'image': (filename, buffer, content_type)}}
			response = requests.post(url, files=files, timeout=5)

			if response.ok:
				result = response.json()
				print(f"✓ Upload OK: {{file_size}} bytes")
			else:
				print(f"✗ Upload failed: HTTP {{response.status_code}}")

		except Exception as e:
			print(f"✗ Upload error: {{type(e).__name__}}: {{e}}")

def onOffToOn(channel, sampleIndex, val, prev):
	"""Alternative callback for off-to-on transitions"""
	pass

def onOnToOff(channel, sampleIndex, val, prev):
	"""Callback for on-to-off transitions"""
	pass

def onWhileOn(channel, sampleIndex, val, prev):
	"""Callback while value is on"""
	pass

def onWhileOff(channel, sampleIndex, val, prev):
	"""Callback while value is off"""
	pass
'''

    execute_dat.text = execute_code
    execute_dat.par.extension = 'py'

    print(f"✓ Created Execute DAT '{execute_name}' with upload callback")
    print(f"  - Render TOP: {render_top_name}")
    print(f"  - Target: http://{ip_address}/upload/image")
    print(f"  - Format: {format}, Quality: {quality}")

    # Position operators nicely
    timer_chop.viewer = True
    execute_dat.viewer = True

    print("\n" + "="*60)
    print("P3A Integration Network Created Successfully!")
    print("="*60)
    print(f"\nTo start uploading:")
    print(f"1. Make sure your render TOP is named '{render_top_name}'")
    print(f"2. Enable the timer: op('{timer_name}').par.start.pulse()")
    print(f"3. Monitor uploads in the textport")
    print(f"\nTo adjust upload rate:")
    print(f"   op('{timer_name}').par.timeout = <rate_in_hz>")
    print(f"\nTo stop uploading:")
    print(f"   op('{timer_name}').par.start = 0")
    print()

    return {
        'timer': timer_chop,
        'execute': execute_dat
    }

# Run the builder with default settings
# Modify these parameters as needed:
ops = build_p3a_integration_network(
    parent_comp=op('/project1'),  # Where to create operators
    render_top_name='render_out',  # Your render TOP name
    upload_rate=2,                 # Upload rate in Hz
    ip_address='p3a.local',        # P3A device IP/hostname
    format='JPEG',                 # PNG, JPEG, or WEBP
    quality=75                     # JPEG/WebP quality
)

print(f"Timer CHOP: {ops['timer'].path}")
print(f"Execute DAT: {ops['execute'].path}")
